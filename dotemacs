;; -*- mode: Lisp; -*-
;;; this was installed by package-install.el.
;;; This provides support for the package system and
;;; interfacing with ELPA, the package archive.
;;; Move this code earlier if you want to reference
;;; packages in your .emacs.
(when
    (load
     (expand-file-name "~/.emacs.d/elpa/package.el"))
  (package-initialize))

;;emacs color themes are in the package emacs-goodies-el on ubuntu
(require 'color-theme)
(color-theme-initialize)
;;here are the ones I find usable
;(color-theme-billw)
(color-theme-gtk-ide)
;(color-theme-katester)
;(color-theme-midnight)
;(color-theme-retro-green)
;(color-theme-retro-orange)
;(color-theme-scintilla)

;;lisp editing is better with flashing brackets
(show-paren-mode)

;; emacs insanely complicated line wrapping section
;; when we wake up, we're in emac's default mode

;; which is to say that there's no line wrapping or anything going on , and when we type outside of the window, all of the line gets displayed, but there are little arrows in the margins. The cursor works as expected (i.e. it moves the position on the screen, so C-p/up-arrow will move 1 space vertical but may stay on the same line number.
;; In this default mode, resizing the window will cause the text to flow. 

;; It's non-optimal for C code though, where you'd rather not have the lines wrapping round. 
;; To do better, use (setq truncate-lines t), which means that each line in the file gets one line in the window, and if you go over the edge, too bad.
;; You won't get a new line starting (either visually or in the file) unless you press RETURN explicitly.
;; You can turn that off with (setq truncate-lines nil), which will get you back to 'see everything' mode

;; For writing text, neither mode is particularly neat, because the default will break words at the edge of the window, which is deeply annoying.
;; For text use (setq word-wrap t), which causes the line breaks to happen at word boundaries.

;; We could use (visual-line-mode), which redefines all the editing commands to work on visual lines.

;; In truncate-lines mode, lines just carry on off the side of the screen, and if you keep typing, the buffer will scroll so that you can always see the cursor

;; You can experiment with this variables
;; (setq truncate-lines t)
;; (setq truncate-lines nil)
;; M-x toggle-truncate-lines

;; (setq word-wrap t)
;; (setq word-wrap nil)
;; M-x toggle-word-wrap

;; There's also 'filling', which is when hard newlines get inserted in the file.

;; Here is a  piece of text. Which is  perhaps a little longer than  it needs to
;; be. If  you press M-q on it  then emacs will insert  hard newlines throughout
;; the  paragraph.   The  place  where   these  newlines  get  inserted  is  the
;; fill-column, which  is usually set around  70. Emacs is careful  not to break
;; words when filling. If you  find yourself pressing M-q to reformat paragraphs
;; often, then you want auto-fill-mode.

;; You can get the fill mode to right-justify text too, using C-u M-q instead of
;; just M-q.


;no line wrapping ;modified for dev8d
;(setq-default truncate-lines nil)
;set fill column for netbook screen
;(setq-default fill-column 80)

;; ;; I'd like for text
;; (setq truncate-lines nil)
;; (setq word-wrap t)
;; (setq fill-column 80)
;; ;; But for code
;; (setq truncate-lines t)
;; (setq word-wrap nil)
;; (setq fill-column 80)

;sane scrolling
(setq scroll-conservatively 10000)

;stop messing about
(setq even-window-heights nil)

; make emacs use the clipboard
(setq x-select-enable-clipboard t)
(setq interprogram-paste-function 'x-cut-buffer-or-selection-value)

;make the set-fill-column key, which I never use, go away and stop
;interfering with C-x C-f for find-file
(global-set-key (kbd "C-x f") 'find-file)

;these only started working after I disabled all the GNOME A-C-arrow etc keys.
(global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-C-<down>") 'shrink-window)
(global-set-key (kbd "S-C-<up>") 'enlarge-window)

;whitespace highlighting is useful for python, but annoying usually
;(global-whitespace-mode)

(setq-default indent-tabs-mode nil)

;; disable overwrite mode, so that accidentally hitting the insert key asks for
;; confirmation
(put 'overwrite-mode 'disabled t)

;; ========== Place Backup Files in Specific Directory ==========
;; Note that a backup gets made the first time you save a file in a session, and not on every save.
;; Enable backup files.
(setq make-backup-files t)
;; And *of course* I want you to make backups of version controlled files as 
;; well, you stupid shed.
(setq vc-make-backup-files t)
; make a copy for backup rather than moving the file and writing a new one.
; means that hard links survive editing.
(setq backup-by-copying t)
;; Keep several previous versions too
(setq version-control t)
;; Just delete the excess old versions without asking
(setq delete-old-versions t)
;; No of versions to keep. probably excessive, but disk space is cheap.
(setq 
  kept-new-versions 100
  kept-old-versions 100)


;; There are various sensible places to put backup files

;; Save all backup file in this directory. Arument one is a regexp so .* matches everything.
;; (setq backup-directory-alist (quote ((".*" . "~/.emacs_backups/"))))
;; Save all backup files in invisible .~ directory in their own directories
;; (setq backup-directory-alist (quote (("." . ".~"))))

;; At the moment my preferred option is to put them all in /tmp. That means that
;; I don't get emacs locking up when the solarflare network is running slow.
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
;; That's also a good place to put auto-save files, come to think of it
( setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))





;; Put the full path of the file being edited in the titlebar
(setq frame-title-format '("%b" (buffer-file-name ": %f")))

;; Save the history of kills, and searches
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(setq savehist-file "~/.emacs.d/tmp/savehist")
(savehist-mode t)

;; disable bell function
(setq ring-bell-function 'ignore)
;; disable toolbar
(tool-bar-mode -1)
;; disable scrollbar
(toggle-scroll-bar -1)
;; disable menu bar
;(menu-bar-mode -1)

;; ;; disable splash screen and show unknown files in speedbar
;; (custom-set-variables
;;  '(inhibit-startup-screen t)
;;  '(speedbar-show-unknown-files t))

;; ;; stop the speedbar jumping around
;; (require 'speedbar)
;; (speedbar-disable-update)
;; ;; and make it show all files
;; ;; (setq speedbar-directory-unshown-regexp "^$")
;; ;; (actually, this can be irritating) original behaviour comes back with:
;; ;; (setq speedbar-directory-unshown-regexp "^\\(\\..*\\)\\'")


;; start emacs server
(server-start)

;; Unique names for buffers with identical filenames
; __init__.py, indeed
(require 'uniquify)
(setq uniquify-buffer-name-style 'reverse)   
(setq uniquify-separator "/")   
(setq uniquify-after-kill-buffer-p t) ; rename after killing uniquified   
(setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers 


;; Swap windows with C-x 8
;; stolen from Steve Yegge at http://steve.yegge.googlepages.com/my-dot-emacs-file
(defun swap-windows ()
  "If you have 2 windows, it swaps them." 
  (interactive) 
  (cond ((not (= (count-windows) 2)) (message "You need exactly 2 windows to do this."))
        (t
         (let* ((w1 (first (window-list)))
                (w2 (second (window-list)))
                (b1 (window-buffer w1))
                (b2 (window-buffer w2))
                (s1 (window-start w1))
                (s2 (window-start w2)))
           (set-window-buffer w1 b2)
           (set-window-buffer w2 b1)
           (set-window-start w1 s2)
           (set-window-start w2 s1)))))

(define-key global-map (kbd "C-x 8") 'swap-windows)

;; Buffer switching foolishness from http://www.telecom.otago.ac.nz/tele402/emacs.html
;; Make it easier to navigate buffers
(iswitchb-mode t)
(add-to-list 'iswitchb-buffer-ignore "*Messages*")
(add-to-list 'iswitchb-buffer-ignore "*Completions")
(add-to-list 'iswitchb-buffer-ignore "*ftp ")
(add-to-list 'iswitchb-buffer-ignore "^[tT][aA][gG][sS]$")





;; Dired command for finding all marked files, use F in dired mode
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))

;; I occasionally find myself needing to gather lines up one by one and paste
;; them all somewhere You can do C-space, end, Cxx, M-C-w, M-w to get an
;; appending yanking version of C-k Or this function should do the same thing.
(defun yank-append-line (arg)
  "Copy lines (as many as prefix argument) to the kill ring, appending to the last kill."
  (interactive "p")
  (append-next-kill)
  (kill-ring-save (point)
                  (line-beginning-position (+ 1 arg)))
  (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

(define-key global-map (kbd "M-k") 'yank-append-line)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; python

;; use the version of python.el in fgallina's github repository
;; which should be checked out in the root directory:
;; cd &&  git clone git://github.com/fgallina/python.el.git
(add-to-list 'load-path "~/python.el/")
(require 'python)

;; use the ~/pyenv virtual environment
(setq python-shell-process-environment
      (list
       (format "PATH=%s" (mapconcat
                          'identity
                          (reverse
                           (cons (getenv "PATH")
                                 '("~/pyenv/bin/")))
                          ":"))
       "VIRTUAL_ENV=~/pyenv"))

(setq python-shell-exec-path '("~/pyenv/bin/"))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; C compilation using F9 for make, F7 and F8 to jump around the errors
(global-set-key [(f9)] 'compile)
(global-set-key [(f7)] 'previous-error)
(global-set-key [(f8)] 'next-error)
(setq compilation-ask-about-save nil)
;(setq compilation-window-height 8)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Clojure-related stuff

;;bind the slime selector to f12 and add a method for finding clojure buffers
(require 'slime)
(define-key global-map (kbd "<f12>") 'slime-selector)
(def-slime-selector-method ?j
  "most recently visited clojure-mode buffer."
  (slime-recently-visited-buffer 'clojure-mode))

;;copy last expression to repl
(defun copy-last-expression-to-clojure-slime-repl()
  "copy-last-expression-to-clojure-slime-repl. Not very clever about it. Finds buffer by name."
  (interactive)
  (let((end (point))
       (beg (save-excursion
              (backward-list 1)
              (point)))
       (edit-buffer (current-buffer))
       (lisp-buffer (get-buffer "*slime-repl clojure*"))
       (eval-command 'slime-repl-return))
  (progn
     (pop-to-buffer lisp-buffer)
     (end-of-buffer)
     (pop-to-buffer edit-buffer)
     (append-to-buffer lisp-buffer beg end)
     (pop-to-buffer lisp-buffer)
     (funcall eval-command)
     (pop-to-buffer edit-buffer))))

(define-key global-map (kbd "C-x C-r") 'copy-last-expression-to-clojure-slime-repl)

;; rainbow brackets in clojure mode, relies on highlight-parentheses.el in 
;; ~/hobby-code
(add-to-list 'load-path "~/hobby-code")
(require 'highlight-parentheses)
(setq hl-paren-colors
      '("orange1" "yellow1" "greenyellow" "green1"
        "springgreen1" "cyan1" "slateblue1" "magenta1" "purple"))
(add-hook 'clojure-mode-hook 
          (lambda () (highlight-parentheses-mode t)))

;; this one takes .clj.html to blogger in clipboard
(fset 'clj-html-to-blogger-copy
   [?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-n ?\C-n ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?. ?c ?l ?o ?j ?u ?r ?e ?- ?\C-s ?/ ?h ?e ?a ?d ?\C-a ?\C-k ?\C-k ?\C-k ?\C-k ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?  ?c ?l ?a ?s ?s ?= ?\" ?c ?l ?o ?j ?u ?r ?e ?- ?b ?o ?o ?\C-? ?d ?y ?\" ?\C-n ?\M-> ?\C-p ?\C-p ?\C-k ?\C-k ?\C-k ?\C-k ?\C-x ?h ?\M-w])

;; keyboard macro of the gods:
;; evaluates the expression on the line BELOW, and pastes the result afterwards
;; set it to be the last keyboard macro, which means that it's executable with f4
(setq last-kbd-macro
  [down ?\C-a ?\C-\M-f ?  ?\; left ?\C-k ?\; ?  ?\C-u ?\C-x ?\C-e])

;; Compile and goto repl
(fset 'compile-and-goto-repl
   "\C-x\C-s\C-c\C-k\C-c\C-z")
;; would be great if we could also add C-c M-p to change package somehow
(global-set-key [f6] 'compile-and-goto-repl)


;;eval and move forwards
(fset 'running-eval
      "\M-\C-x\M-\C-e")
(global-set-key [f5] 'running-eval)


;; save a list of open files in ~/.emacs.desktop
(desktop-save-mode t)

;; only restore the first few buffers when restoring a desktop. The rest get restored in the background, which means emacs becomes responsive earlier.
(setq desktop-restore-eager 5)

;; save a bunch of variables to the desktop file
;; for lists specify the len of the maximal saved data also
(setq desktop-globals-to-save
      (append '((extended-command-history . 30)
                (file-name-history        . 100)
                (grep-history             . 30)
                (compile-history          . 30)
                (minibuffer-history       . 50)
                (query-replace-history    . 60)
                (read-expression-history  . 60)
                (regexp-history           . 60)
                (regexp-search-ring       . 20)
                (search-ring              . 20)
                (shell-command-history    . 50)
                tags-file-name
                register-alist)))


(defun path-to-clipboard ()
  "Copy the current file's path to the clipboard.
  If the current buffer has no file, copy the buffer's default directory."
  (interactive)
  (let ((path (expand-file-name (or (buffer-file-name) default-directory))))
    (kill-new path)
    (message "%s" path)))

(defun revert-all-buffers ()
  "Refreshes all open buffers from their respective files."
  (interactive)
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (and (buffer-file-name) (not (buffer-modified-p)))
        (revert-buffer t t t) )))
  (message "Refreshed open files."))

(put 'upcase-region 'disabled nil)


;; splits the screen into three windows which I like at the moment
(fset 'split
   [?\C-x ?b ?j ?l ?a ?. ?c return ?\C-x ?3 ?\C-x ?o ?\C-x ?b ?s ?a ?m ?p ?l ?e ?. ?c return ?\C-x ?2 ?\C-x ?o ?\C-x ?b ?* ?c ?o ?m ?p ?i ?l ?a ?t ?i ?o ?n ?* ])

(defun sdesk ()
   (interactive)
   (desktop-read "~/solarflare-desktop"))

(defun sdesk-save ()
   (interactive)
   (desktop-save "~/solarflare-desktop"))

;; Winner mode, only set up to use the window keys
;; http://emacs-fu.blogspot.com/search?q=windows
(require 'winner)
(setq winner-dont-bind-my-keys t) ;; default bindings conflict with org-mode

(global-set-key (kbd "<C-s-left>") 'winner-undo)
(global-set-key (kbd "<C-s-right>") 'winner-redo)

(setq org-support-shift-select 'always)


(winner-mode t) ;; turn on the global minor mode
(put 'downcase-region 'disabled nil)


;; googling code
(add-to-list 'load-path "~/hobby-code")
(require 'google-search)


;; version of that for solarflare's autodocs
(require 'url)

(defvar autodocs-search-maxlen 50 "Maximum string length of search term")

(defun autodocs-search-selection ()
  "Search autodocs for current selection"
  (interactive)
  (let ((term (if (use-region-p)
                  (let ((start (region-beginning))
                        (end   (region-end)))
                    (if (> (- end start) autodocs-search-maxlen)
                        (buffer-substring start (+ start autodocs-search-maxlen))
                      (buffer-substring start end)))
                (read-string "autodocs search: "))))
    (browse-url (concat "http://ukservices.uk.solarflarecom.com/cgi-bin/htsearch?config=htdig&restrict=&exclude=&method=and&format=builtin-long&words="
                        (url-hexify-string (encode-coding-string term 'utf-8))))))

(defun ass () "autodocs-search-selection" (interactive) (autodocs-search-selection))

(defun region-find-grep (directory)
  (interactive)
  (let ((term (if (use-region-p)
                  (buffer-substring (region-beginning) (region-end))
                (read-string (concat  "region-find-grep: (" directory ") ")))))
    (grep-find (concat "ack --smart-case --no-heading --no-color \"" (shell-quote-argument term)  "\" " directory))))


(defun fgf()
  (interactive)
  (region-find-grep "~/myco/firmwaresrc"))


(defun fgh()
  (interactive)
  (region-find-grep "/projects/huntington_A0/Work/jla/hunt"))


;; only do horizontal splitting
;;(setq split-height-threshold nil)
;;(setq split-width-threshold 0)

(require 'ido)
(ido-mode 'both)



;; ido makes competing buffers and finding files easier
;; http://www.emacswiki.org/cgi-bin/wiki/InteractivelyDoThings
(require 'ido) 

(setq 
  ido-save-directory-list-file "~/.emacs.d/cache/ido.last"

  ido-ignore-buffers ;; ignore these guys
  '("\\` " "^\*Mess" "^\*Back" ".*Completion" "^\*Ido" "^\*trace"

     "^\*compilation" "^\*GTAGS" "^session\.*" "^\*")
  ido-work-directory-list '("~/" "~/Desktop" "~/Documents" "~src")
  ido-case-fold  t                 ; be case-insensitive

  ido-enable-last-directory-history t ; remember last used dirs
  ido-max-work-directory-list 30   ; should be enough
  ido-max-work-file-list      50   ; remember many
  ido-use-filename-at-point nil    ; don't use filename at point (annoying)
  ido-use-url-at-point nil         ; don't use url at point (annoying)

  ido-enable-flex-matching nil     ; don't try to be too smart
  ido-max-prospects 8              ; don't spam my minibuffer
  ido-confirm-unique-completion t) ; wait for RET, even with unique completion

;; when using ido, the confirmation is rather annoying...
 (setq confirm-nonexistent-file-or-buffer nil)


(ido-mode 'both) ;; for buffers and files

(require 'windmove)
(windmove-default-keybindings 'super)


(add-hook 'c-mode-common-hook
  (lambda()
    (local-set-key (kbd "C-c <right>") 'hs-show-block)
    (local-set-key (kbd "C-c <left>")  'hs-hide-block)
    (local-set-key (kbd "C-c <up>")    'hs-hide-all)
    (local-set-key (kbd "C-c <down>")  'hs-show-all)
    (hs-minor-mode t)))

;; undo tree mode is unbelievably awesome, and it comes from:
;; http://www.dr-qubit.org/undo-tree/undo-tree.el
;; I stuck the code in ~/hobby-code. It might be an idea to go and get the latest version someday.
;; I've not version-controlled the byte compiled .elc file
;; use M-x byte-compile on the .el file to make an .elc file
(require 'undo-tree)
(global-undo-tree-mode)











