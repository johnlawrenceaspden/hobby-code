;; Gambler's Problem

;; boot repl
;; (load-file "gamblers.clj")

;; boot repl
;; M-x cider-connect from emacs

;; boot -f gamblers.clj
(set-env! :dependencies '[[simple-plotter "0.1.2"]])

;; comment out the set-env above and run with:
;; cd ~/hobby-code/reinforcement-learning/ ; time java -cp /home/john/.m2/repository/org/clojure/clojure/1.7.0/clojure-1.7.0.jar:/home/john/.m2/repository/simple-plotter/simple-plotter/0.1.2/simple-plotter-0.1.2.jar clojure.main -i gamblers.clj


(use 'simple-plotter.core)



(def pwin 0.4)
(def plose (- 1 pwin))



(defn abs[x] (if (< x 0) (- x) x))
(map abs (range -5 5)) ; (5 4 3 2 1 0 1 2 3 4)

(defn linfinity [v1 v2]
  (assert (= (count v1) (count v2)))
  (reduce max (map abs (map - v1 v2))))

(linfinity [0 2 3] [0 -2 3])

;; We got states 0..100, let's take initial values 0

;; everything is worthless
(def v0 (vec (repeat 101 0 )))

(defn bellman-update [v, n, stake]
  (if (#{0,100} n) 0 
      (let [win  (+ n stake)
            loss (- n stake)]
        (assert (and (<= 0 loss) (<= win 100)))
        (cond (< win 100)
              (+ (* pwin (v win)) (* plose (v loss)))
              (= 100 win)
              (+ (* pwin (+ 1 (v win))) (* plose (v loss)))
              :else :fuuuck))))

(defn available-actions [s]
  (if (#{0,100} s) (list 0)
      (range 1 (inc (min s (- 100 s))))))

(defn sorted-actions [v n]
  (reverse (sort
   (for [a (available-actions n)] [(bellman-update v n a) a]))))

(defn optimal-action [v n]
  (second (first (sorted-actions v n))))

(defn value-update [v n]
  (bellman-update v n (optimal-action v n)))

(defn value-iterate [v]
  (mapv (fn [n] (value-update v n)) (range 0 101)))

(def vvseries (iterate value-iterate v0)) ; #'user/vvseries

(def vvshifts (map linfinity vvseries (drop 1 vvseries))) ;  ; #'user/vvshifts

(take 60 vvshifts) ; (0.4 0.24 0.14400000000000002 0.08640000000000003 0.05184 0.03110400000000002 0.012441599999999942 0.007464959999999965 0.0029859840000000526 0.0017915904000000982 0.0010749542400000367 6.449725439999776E-4 2.5798901759999104E-4 1.0319560703997421E-4 4.127824281596748E-5 2.476694568953608E-5 9.906778275947659E-6 5.944066965524186E-6 2.3776267861208567E-6 9.51050714514956E-7 3.804202859392092E-7 1.5216811444229705E-7 9.130086864317377E-8 5.4780521230313184E-8 3.286831273818791E-8 1.9720987620708286E-8 7.888395048283314E-9 4.7330370733789096E-9 1.8932148071471033E-9 1.1359289064927225E-9 6.81557366100094E-10 4.089343308422144E-10 1.6357382115472774E-10 6.542955066635159E-11 2.617195349330359E-11 1.5702994460298214E-11 6.281419828724211E-12 3.768541034787631E-12 1.5074608228360376E-12 6.031841692788475E-13 2.4136248555350903E-13 9.658940314238862E-14 5.795364188543317E-14 3.4861002973229915E-14 2.0872192862952943E-14 1.2545520178264269E-14 5.10702591327572E-15 2.9976021664879227E-15 1.2212453270876722E-15 7.771561172376096E-16 4.440892098500626E-16 3.3306690738754696E-16 2.220446049250313E-16 1.1102230246251565E-16 1.1102230246251565E-16 1.1102230246251565E-16 1.1102230246251565E-16 4.3368086899420177E-19 0 0)

(def itcount (count (take-while (fn[x] (> (abs x) 0.0000000000001)) vvshifts))) ; #'boot.user/itcount 

itcount ; 41

(def optv (nth vvseries itcount)) ; #'boot.user/optv 

optv ; [0 0.0020656247765006063 0.005164061941358714 0.009225471067747303 0.012910154853396786 0.017385398981274416 0.023063677669475455 0.027814113056216477 0.03227538713349196 0.03768507279530841 0.04346349745329324 0.050354469980630326 0.05765919417368864 0.0652393748658575 0.0695352826406484 0.07443123938872179 0.0806884678337299 0.08661104367714217 0.0942126819883782 0.10314362491947164 0.10865874363323309 0.11596662620624244 0.125886174951683 0.13357997572370262 0.14414798543422158 0.16000000000000003 0.16309843716475095 0.1677460929120381 0.173838206601621 0.1793652322800952 0.18607809847191165 0.1945955165042132 0.20172116958432476 0.208413080700238 0.21652760919296266 0.2251952461799399 0.2355317049709455 0.24648879126053297 0.25785906229878625 0.26430292396097266 0.2716468590830827 0.2810327017505949 0.2899165655157133 0.3013190229825673 0.3147154373792075 0.3229881154498497 0.3339499393093637 0.34882926242752454 0.36036996358555395 0.3762219781513324 0.4 0.4030984371647509 0.4077460929120381 0.41383820660162096 0.4193652322800952 0.42607809847191164 0.4345955165042132 0.4417211695843247 0.448413080700238 0.45652760919296265 0.4651952461799399 0.4755317049709455 0.48648879126053296 0.49785906229878624 0.5043029239609726 0.5116468590830827 0.5210327017505949 0.5299165655157133 0.5413190229825673 0.5547154373792075 0.5629881154498497 0.5739499393093637 0.5888292624275245 0.600369963585554 0.6162219781513324 0.64 0.6446476557471263 0.6516191393680572 0.6607573099024315 0.6690478484201428 0.6791171477078675 0.6918932747563198 0.7025817543764871 0.712619621050357 0.724791413789444 0.7377928692699098 0.7532975574564182 0.7697331868907995 0.7867885934481793 0.796454385941459 0.8074702886246241 0.8215490526258922 0.83487484827357 0.851978534473851 0.8720731560688111 0.8844821731747745 0.9009249089640454 0.9232438936412867 0.9405549453783308 0.9643329672269985 0]


(do
  (create-window "convergence of value function" 2000 1000 black white 0 100 0 1.0)
  (doseq [v (take itcount vvseries)]
    (doseq [n (range 100)]
      (line (inc n) (v (inc n)) n (v n)))))

(def pi-optimal (mapv (fn [n] (optimal-action optv n)) (range 101))) ; #'user/pi-optimal

pi-optimal ; [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 10 16 17 18 19 20 21 22 23 24 25 26 27 22 29 30 31 32 8 34 35 36 37 12 11 40 9 42 43 44 45 46 3 2 1 50 49 48 47 46 45 44 43 8 41 40 39 38 37 36 35 34 33 32 31 20 29 28 27 26 25 24 23 22 21 20 19 7 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0]

(sorted-actions optv 50) ; ([0.4 50] [0.3869725617566998 1] [0.38697256175669975 49] [0.37932041531614763 2] [0.3793204153161476 48] [0.3748328400971631 47] [0.3748328400971631 3] [0.36811605649765633 4] [0.3681160564976563 46] [0.3642241086586745 45] [0.3642241086586745 5] [0.36266746902920977 6] [0.3626674690292097 44] [0.3574798816232703 43] [0.35747988162327027 7] [0.3533151715895232 42] [0.3533151715895232 8] [0.35200000000000004 25] [0.351230664727542 9] [0.35123066472754194 41] [0.34931095388348493 38] [0.34931095388348493 12] [0.34906621392182563 40] [0.3490662139218256 10] [0.3487944363649618 39] [0.34879443636496177 11] [0.34703689967583434 37] [0.3470368996758343 13] [0.3443478535593835 24] [0.34434785355938347 26] [0.3430401925669564 14] [0.34304019256695634 36] [0.34079564118144445 27] [0.34079564118144445 23] [0.33983462893198246 22] [0.3398346289319824 28] [0.339775891341197 35] [0.339775891341197 15] [0.3386434848542109 31] [0.3386434848542109 19] [0.3383296462160156 16] [0.3383296462160155 34] [0.3375603109436218 18] [0.33756031094362177 32] [0.3371991150918026 21] [0.33719911509180256 29] [0.33701447462642814 17] [0.3370144746264281 33] [0.3368421052630869 30] [0.3368421052630869 20])

(sorted-actions optv 20) ; ([0.10865874363323309 20] [0.10865874363323308 5] [0.10827282543417996 1] [0.10696054445028944 19] [0.10696054445028942 6] [0.10688207917370013 2] [0.10624206208432974 18] [0.10624206208432974 7] [0.10607227487392658 4] [0.10539861649576635 3] [0.10413079914486158 17] [0.10413079914486158 8] [0.10195877490041627 16] [0.10195877490041627 9] [0.10050933786074062 15] [0.1005093378607406 10] [0.10044925027887035 14] [0.10044925027887032 11] [0.1000537001138251 13] [0.10005370011382508 12])
(optv 20) ; 0.10865874363323309

pi-optimal ; [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 1 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0]

(use 'simple-plotter.core)

(do 
  (create-window "optimal policy" 2000 1000 black white 0 100 0 50)
  (let [pio (mapv (fn[n] (if n n 0)) pi-optimal)]
    (doseq [n (range 101)]
      (line n 0 n (pio n)))))


(do
  (create-window "value function for optimal policy" 2000 1000 black white 0 100 0 1.0)
  (doseq [n (range 101)]
    (line n 0 n (optv n))))

